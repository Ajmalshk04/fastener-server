=======================================================================
C:\My-Projects\Fastners-new\server\config\config.js

// config.js
require("dotenv").config();

module.exports = {
  PORT: process.env.PORT || 5000,
  MONGO_URI: process.env.MONGO_URI,
  JWT_SECRET: process.env.JWT_SECRET,
  JWT_EXPIRE: process.env.JWT_EXPIRE || "30d",
  SMTP_HOST: process.env.SMTP_HOST,
  SMTP_PORT: process.env.SMTP_PORT,
  SMTP_USER: process.env.SMTP_USER,
  SMTP_PASS: process.env.SMTP_PASS,
  FROM_EMAIL: process.env.FROM_EMAIL,
};


=======================================================================
C:\My-Projects\Fastners-new\server\config\dbConnection.js

// dbConnection.js
const mongoose = require("mongoose");
const config = require("./config");

const connectDB = async () => {
  try {
    await mongoose.connect(config.MONGO_URI);
    console.log("MongoDB connected");
  } catch (error) {
    console.error("MongoDB connection error:", error);
    process.exit(1);
  }
};

module.exports = connectDB;


=======================================================================
C:\My-Projects\Fastners-new\server\controllers\adminControllers.js

// adminController.js
const User = require("../models/userModel");
const Project = require("../models/projectModel");
const Quotation = require("../models/quotationModel");
const { sendEmail } = require("../helpers/emailHelper");

exports.getAllUsers = async (req, res) => {
  try {
    const users = await User.find({ role: "customer" });
    res.status(200).json({ success: true, count: users.length, data: users });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};
exports.getAllSuppliers = async (req, res) => {
  try {
    const users = await User.find({ role: "supplier" });
    res.status(200).json({ success: true, count: users.length, data: users });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.getUserById = async (req, res) => {
  try {
    const user = await User.findById(req.params.id);
    if (!user) {
      return res
        .status(404)
        .json({ success: false, message: "User not found" });
    }
    res.status(200).json({ success: true, data: user });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.updateUser = async (req, res) => {
  try {
    const user = await User.findByIdAndUpdate(req.params.id, req.body, {
      new: true,
      runValidators: true,
    });
    if (!user) {
      return res
        .status(404)
        .json({ success: false, message: "User not found" });
    }
    res.status(200).json({ success: true, data: user });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.deleteUser = async (req, res) => {
  try {
    const user = await User.findByIdAndDelete(req.params.id);
    if (!user) {
      return res
        .status(404)
        .json({ success: false, message: "User not found" });
    }
    res.status(200).json({ success: true, message: "User Deleted Successful" });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.getDashboardStats = async (req, res) => {
  try {
    const totalUsers = await User.countDocuments();
    const totalProjects = await Project.countDocuments();
    const totalQuotations = await Quotation.countDocuments();
    const recentProjects = await Project.find().sort("-createdAt").limit(5);
    const recentQuotations = await Quotation.find().sort("-createdAt").limit(5);

    res.status(200).json({
      success: true,
      data: {
        totalUsers,
        totalProjects,
        totalQuotations,
        recentProjects,
        recentQuotations,
      },
    });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.forwardProjectToSuppliers = async (req, res) => {
  try {
    const project = await Project.findById(req.params.id);
    if (!project) {
      return res
        .status(404)
        .json({ success: false, message: "Project not found" });
    }

    const suppliers = await User.find({ role: "supplier" });
    for (let supplier of suppliers) {
      await sendEmail(
        supplier.email,
        "New Project Available for Quotation",
        `A new project "${project.title}" is available for quotation. Please log in to your account to view details and submit your quote.`
      );
    }

    project.status = "SUBMITTED";
    await project.save();

    res.status(200).json({
      success: true,
      message: "Project forwarded to suppliers successfully",
    });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.reviewQuotation = async (req, res) => {
  try {
    const { quotationId, status, adminComment } = req.body;
    const quotation = await Quotation.findById(quotationId);

    if (!quotation) {
      return res
        .status(404)
        .json({ success: false, message: "Quotation not found" });
    }

    quotation.status = status;
    quotation.adminComment = adminComment;
    await quotation.save();

    // Notify supplier about the quotation review
    const supplier = await User.findById(quotation.supplier);
    await sendEmail(
      supplier.email,
      "Quotation Review Update",
      `Your quotation for project "${quotation.project.title}" has been ${status}. Admin comment: ${adminComment}`
    );

    res.status(200).json({
      success: true,
      message: "Quotation reviewed successfully",
      data: quotation,
    });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};


=======================================================================
C:\My-Projects\Fastners-new\server\controllers\projectControllers.js

// projectController.js
const Project = require("../models/projectModel");
const User = require("../models/userModel");
const { sendEmail } = require("../helpers/emailHelper");
const APIFeatures = require("../utils/apiFeatures");

exports.createProject = async (req, res) => {
  try {
    const project = await Project.create({
      ...req.body,
      user: req.user._id,
    });

    // Notify admin about new project
    const admins = await User.find({ role: "admin" });
    for (let admin of admins) {
      await sendEmail(
        admin.email,
        "New Project Created",
        `A new project "${project.title}" has been created and needs your attention.`
      );
    }

    res.status(201).json({ success: true, data: project });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.getProjects = async (req, res) => {
  try {
    const features = new APIFeatures(
      Project.find().populate("customer"),
      req.query
    )
      .search()
      .filter()
      .sort()
      .limitFields()
      .paginate();

    const projects = await features.query;

    res
      .status(200)
      .json({ success: true, count: projects.length, data: projects });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.getProjectById = async (req, res) => {
  try {
    const project = await Project.findById(req.params.id).populate("supplier");
    if (!project) {
      return res
        .status(404)
        .json({ success: false, message: "Project not found" });
    }
    res.status(200).json({ success: true, data: project });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.getProjectByUserId = async (req, res) => {
  try {
    console.log("Project-MONGOID", req.user);

    const project = await Project.find({ user: req.user._id });
    if (!project) {
      return res
        .status(404)
        .json({ success: false, message: "Project not found" });
    }
    res.status(200).json({ success: true, data: project });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.updateProject = async (req, res) => {
  try {
    const project = await Project.findByIdAndUpdate(req.params.id, req.body, {
      new: true,
      runValidators: true,
    });
    if (!project) {
      return res
        .status(404)
        .json({ success: false, message: "Project not found" });
    }
    res.status(200).json({ success: true, data: project });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.deleteProject = async (req, res) => {
  try {
    const project = await Project.findByIdAndDelete(req.params.id);
    if (!project) {
      return res
        .status(404)
        .json({ success: false, message: "Project not found" });
    }
    res.status(200).json({ success: true, data: "Project Deleted Successful" });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.forwardToSuppliers = async (req, res) => {
  try {
    const project = await Project.findById(req.params.id);
    if (!project) {
      return res
        .status(404)
        .json({ success: false, message: "Project not found" });
    }

    const suppliers = await User.find({ role: "supplier" });
    for (let supplier of suppliers) {
      await sendEmail(
        supplier.email,
        "New Project Opportunity",
        `A new project "${project.title}" is available for quotation. Please check your dashboard for details.`
      );
    }

    project.status = "SUBMITTED";
    await project.save();

    res
      .status(200)
      .json({ success: true, message: "Project forwarded to suppliers" });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};


=======================================================================
C:\My-Projects\Fastners-new\server\controllers\quotationControllers.js

// quotationController.js
const Quotation = require("../models/quotationModel");
const Project = require("../models/projectModel");
const User = require("../models/userModel");
const { sendEmail } = require("../helpers/emailHelper");
const APIFeatures = require("../utils/apiFeatures");

exports.createQuotation = async (req, res) => {
  try {
    const quotation = await Quotation.create({
      ...req.body,
      supplier: req.user.id,
    });

    // Notify admin about new quotation
    const admins = await User.find({ role: "admin" });
    for (let admin of admins) {
      await sendEmail(
        admin.email,
        "New Quotation Received",
        `A new quotation has been submitted for project "${quotation.project.title}".`
      );
    }

    res.status(201).json({ success: true, data: quotation });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.getQuotations = async (req, res) => {
  try {
    const features = new APIFeatures(Quotation.find(), req.query)
      .filter()
      .sort()
      .limitFields()
      .paginate();

    const quotations = await features.query;

    res
      .status(200)
      .json({ success: true, count: quotations.length, data: quotations });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.getQuotationById = async (req, res) => {
  try {
    const quotation = await Quotation.findById(req.params.id);
    if (!quotation) {
      return res
        .status(404)
        .json({ success: false, message: "Quotation not found" });
    }
    res.status(200).json({ success: true, data: quotation });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.updateQuotation = async (req, res) => {
  try {
    const quotation = await Quotation.findByIdAndUpdate(
      req.params.id,
      req.body,
      {
        new: true,
        runValidators: true,
      }
    );
    if (!quotation) {
      return res
        .status(404)
        .json({ success: false, message: "Quotation not found" });
    }
    res.status(200).json({ success: true, data: quotation });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.acceptQuotation = async (req, res) => {
  try {
    const quotation = await Quotation.findById(req.params.id);
    if (!quotation) {
      return res
        .status(404)
        .json({ success: false, message: "Quotation not found" });
    }

    quotation.status = "ACCEPTED";
    await quotation.save();

    const project = await Project.findById(quotation.project);
    project.supplier = quotation.supplier;
    project.status = "IN_PRODUCTION";
    await project.save();

    // Notify supplier about accepted quotation
    const supplier = await User.findById(quotation.supplier);
    await sendEmail(
      supplier.email,
      "Quotation Accepted",
      `Your quotation for project "${project.title}" has been accepted.`
    );

    // Notify customer about accepted quotation
    const customer = await User.findById(project.customer);
    await sendEmail(
      customer.email,
      "Project Update",
      `A supplier has been selected for your project "${project.title}". Production will begin soon.`
    );

    res.status(200).json({
      success: true,
      message: "Quotation accepted and project updated",
    });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};


=======================================================================
C:\My-Projects\Fastners-new\server\controllers\supplierControllers.js

// supplierController.js
const Supplier = require("../models/supplierModel");
const User = require("../models/userModel");
const Project = require("../models/projectModel");
const APIFeatures = require("../utils/apiFeatures");
const projectUpdateModel = require("../models/projectUpdateModel");

exports.getSuppliers = async (req, res) => {
  try {
    const features = new APIFeatures(Supplier.find(), req.query)
      .filter()
      .sort()
      .limitFields()
      .paginate();

    const suppliers = await features.query;

    res
      .status(200)
      .json({ success: true, count: suppliers.length, data: suppliers });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.getSupplierById = async (req, res) => {
  try {
    const supplier = await Supplier.findById(req.params.id).populate(
      "user",
      "firstName lastName email"
    );
    if (!supplier) {
      return res
        .status(404)
        .json({ success: false, message: "Supplier not found" });
    }
    res.status(200).json({ success: true, data: supplier });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};
exports.getSupplierByUserId = async (req, res) => {
  try {
    const user = req.user;

    // Ensure that user._id is being passed correctly as an ObjectId
    if (!user || !user._id) {
      return res
        .status(400)
        .json({ success: false, message: "User ID is not valid" });
    }

    const supplier = await Supplier.findOne({ user: user._id }).populate(
      "user",
      "firstName lastName email"
    );
    if (!supplier) {
      return res
        .status(404)
        .json({ success: false, message: "Supplier not found" });
    }
    res.status(200).json({ success: true, data: supplier });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.updateSupplier = async (req, res) => {
  try {
    let updateData = req.body;

    // If competencies are being updated, ensure they're added to manufacturingCapabilities
    if (req.body.competencies) {
      updateData = {
        ...req.body,
        manufacturingCapabilities: req.body.competencies,
      };
      delete updateData.competencies; // Remove the temporary competencies field
    }

    const supplier = await Supplier.findByIdAndUpdate(
      req.params.id,
      updateData,
      {
        new: true,
        runValidators: true,
      }
    );

    if (!supplier) {
      return res
        .status(404)
        .json({ success: false, message: "Supplier not found" });
    }
    res.status(200).json({ success: true, data: supplier });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.getSupplierProjects = async (req, res) => {
  try {
    const supplierId = req.params.id;
    const supplier = await Supplier.findById(supplierId);

    if (!supplier) {
      return res
        .status(404)
        .json({ success: false, message: "Supplier not found" });
    }

    // Check if the logged-in user is the supplier or an admin
    if (req.user.role !== "admin" && supplier.user.toString() !== req.user.id) {
      return res.status(403).json({
        success: false,
        message: "Not authorized to view these projects",
      });
    }

    const features = new APIFeatures(
      Project.find({ supplier: supplierId }),
      req.query
    )
      .search()
      .filter()
      .sort()
      .limitFields()
      .paginate();

    const projects = await features.query;

    res.status(200).json({
      success: true,
      count: projects.length,
      data: projects,
    });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.updateProjectStatus = async (req, res) => {
  try {
    const { projectId, status, description } = req.body;
    const project = await Project.findById(projectId);

    if (!project) {
      return res
        .status(404)
        .json({ success: false, message: "Project not found" });
    }

    const supplier = await Supplier.findOne({ user: req.user.id });
    if (!supplier || project.supplier.toString() !== supplier._id.toString()) {
      return res.status(403).json({
        success: false,
        message: "Not authorized to update this project",
      });
    }

    project.status = status;
    await project.save();

    // Create a new project update
    const projectUpdate = await projectUpdateModel.create({
      project: projectId,
      supplier: supplier._id,
      description,
      status,
    });

    // Notify customer about the update
    const customer = await User.findById(project.customer);
    await sendEmail(
      customer.email,
      "Project Update",
      `Your project "${project.title}" has been updated to status: ${status}. Update: ${description}`
    );

    res.status(200).json({
      success: true,
      message: "Project status updated",
      data: { project, projectUpdate },
    });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};


=======================================================================
C:\My-Projects\Fastners-new\server\controllers\userControllers.js

// userController.js
const User = require("../models/userModel");
const Customer = require("../models/customerModel");
const Supplier = require("../models/supplierModel");
const Admin = require("../models/adminModel");
const { sendEmail } = require("../helpers/emailHelper");
const { generateOTP } = require("../helpers/otpHelper");
const bcrypt = require("bcryptjs");

exports.register = async (req, res) => {
  try {
    const { email, password, firstName, lastName, role, company, phoneNumber } =
      req.body;

    const user = await User.create({
      email,
      password,
      firstName,
      lastName,
      role,
      company,
      phoneNumber,
    });

    const otp = generateOTP();
    user.otp = {
      code: otp,
      expiresAt: Date.now() + 10 * 60 * 1000, // OTP valid for 10 minutes
    };
    await user.save();

    // Create role-specific profile
    if (role === "customer") {
      await Customer.create({ user: user._id });
    } else if (role === "supplier") {
      await Supplier.create({ user: user._id, companyName: company });
    } else if (role === "admin") {
      await Admin.create({ user: user._id });
    }

    await sendEmail(email, "Verify Your Account", `Your OTP is: ${otp}`);
    res.status(201).json({
      success: true,
      message: "User registered. Please check your email for OTP.",
    });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;
    const user = await User.findOne({ email }).select("+password");

    if (!user.isVerified) {
      return res
        .status(401)
        .json({ success: false, message: "Please verify your account first" });
    }

    if (!user || !(await user.matchPassword(password))) {
      return res
        .status(401)
        .json({ success: false, message: "Invalid credentials" });
    }

    const token = user.getSignedJwtToken();
    res.status(200).json({ success: true, token });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.verifyOTP = async (req, res) => {
  try {
    const { email, otp } = req.body;
    const user = await User.findOne({ email });
    if (!user) {
      return res
        .status(404)
        .json({ success: false, message: "User not found" });
    }
    if (user.otp.code !== otp || user.otp.expiresAt < Date.now()) {
      return res
        .status(400)
        .json({ success: false, message: "Invalid or expired OTP" });
    }
    user.isVerified = true;
    user.otp = undefined;
    await user.save();
    res
      .status(200)
      .json({ success: true, message: "Account verified successfully" });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.resendOTP = async (req, res) => {
  try {
    const { email } = req.body;
    const user = await User.findOne({ email });
    if (!user) {
      return res
        .status(404)
        .json({ success: false, message: "User not found" });
    }
    const otp = generateOTP();
    user.otp = {
      code: otp,
      expiresAt: Date.now() + 10 * 60 * 1000,
    };
    await user.save();
    await sendEmail(
      email,
      "New OTP for Account Verification",
      `Your new OTP is: ${otp}`
    );
    res
      .status(200)
      .json({ success: true, message: "New OTP sent to your email" });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.getProfile = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    let profile;
    if (user.role === "customer") {
      profile = await Customer.findOne({ user: user._id });
    } else if (user.role === "supplier") {
      profile = await Supplier.findOne({ user: user._id });
    } else if (user.role === "admin") {
      profile = await Admin.findOne({ user: user._id });
    }
    res.status(200).json({ success: true, data: { user, profile } });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.updateProfile = async (req, res) => {
  try {
    const user = await User.findByIdAndUpdate(req.user.id, req.body, {
      new: true,
      runValidators: true,
    });
    let profile;
    if (user.role === "customer") {
      profile = await Customer.findOneAndUpdate({ user: user._id }, req.body, {
        new: true,
        runValidators: true,
      });
    } else if (user.role === "supplier") {
      profile = await Supplier.findOneAndUpdate({ user: user._id }, req.body, {
        new: true,
        runValidators: true,
      });
    } else if (user.role === "admin") {
      profile = await Admin.findOneAndUpdate({ user: user._id }, req.body, {
        new: true,
        runValidators: true,
      });
    }
    res.status(200).json({ success: true, data: { user, profile } });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.updatePassword = async (req, res) => {
  try {
    const { oldPassword, newPassword } = req.body;
    console.log(oldPassword, newPassword);

    const user = await User.findById(req.user.id).select("+password");
    console.log(user);

    if (!user) {
      return res
        .status(404)
        .json({ success: false, message: "User not found" });
    }
    const isMatch = await bcrypt.compare(oldPassword, user.password);
    if (!isMatch) {
      return res
        .status(401)
        .json({ success: false, message: "Incorrect old password" });
    }
    console.log(newPassword);

    user.password = newPassword;
    await user.save();
    res
      .status(200)
      .json({ success: true, message: "Password updated successfully" });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Internal server error",
      error: error.message,
    });
  }
};

exports.forgotPassword = async (req, res) => {
  try {
    const { email } = req.body;
    const user = await User.findOne({ email });
    if (!user) {
      return res
        .status(404)
        .json({ success: false, message: "User not found" });
    }
    const resetToken = jwt.sign({ id: user._id }, process.env.RESET_SECRET, {
      expiresIn: "1h",
    });
    const resetLink = `http://localhost:5173/reset-password?token=${resetToken}`; // Replace with your frontend URL
    await sendEmail(
      email,
      "Password Reset Request",
      `Please use the following link to reset your password: ${resetLink}`
    );
    res
      .status(200)
      .json({ success: true, message: "Password reset link sent to email" });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Internal server error",
      error: error.message,
    });
  }
};

exports.resetPassword = async (req, res) => {
  try {
    const { token, newPassword } = req.body;
    const decoded = jwt.verify(token, process.env.RESET_SECRET);
    const user = await User.findById(decoded.id).select("+password");
    if (!user) {
      return res
        .status(404)
        .json({ success: false, message: "User not found" });
    }
    user.password = await bcrypt.hash(newPassword, 10);
    await user.save();
    res
      .status(200)
      .json({ success: true, message: "Password reset successfully" });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Internal server error",
      error: error.message,
    });
  }
};


=======================================================================
C:\My-Projects\Fastners-new\server\helpers\emailHelper.js

// emailHelper.js
const nodemailer = require("nodemailer");
const config = require("../config/config");

exports.sendEmail = async (to, subject, text) => {
  const transporter = nodemailer.createTransport({
    host: config.SMTP_HOST,
    port: config.SMTP_PORT,
    auth: {
      user: config.SMTP_USER,
      pass: config.SMTP_PASS,
    },
  });

  await transporter.sendMail({
    from: config.FROM_EMAIL,
    to,
    subject,
    text,
  });
};

// otpHelper.js
exports.generateOTP = () => {
  return Math.floor(100000 + Math.random() * 900000).toString();
};


=======================================================================
C:\My-Projects\Fastners-new\server\helpers\otpHelper.js

const crypto = require("node:crypto");

const generateOTP = () => {
  const otp = crypto.randomInt(100000, 999999).toString();
  return otp;
};

module.exports = { generateOTP };


=======================================================================
C:\My-Projects\Fastners-new\server\middleware\authMiddleware.js

// authMiddleware.js
const jwt = require("jsonwebtoken");
const User = require("../models/userModel");
const config = require("../config/config");

exports.protect = async (req, res, next) => {
  let token;
  if (
    req.headers.authorization &&
    req.headers.authorization.startsWith("Bearer")
  ) {
    token = req.headers.authorization.split(" ")[1];
  }
  if (!token) {
    return res
      .status(401)
      .json({ success: false, message: "Not authorized to access this route" });
  }
  try {
    const decoded = jwt.verify(token, config.JWT_SECRET);
    req.user = await User.findById(decoded.id);
    if (!req.user) {
      return res.status(401).json({
        success: false,
        message: "Not authorized to access this route",
      });
    }
    next();
  } catch (error) {
    return res
      .status(401)
      .json({ success: false, message: "Not authorized to access this route" });
  }
};

exports.authorize = (...roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({
        success: false,
        message: "User role is not authorized to access this route",
      });
    }
    next();
  };
};


=======================================================================
C:\My-Projects\Fastners-new\server\models\adminModel.js

const mongoose = require("mongoose");
const { Schema } = mongoose;

const AdminSchema = new Schema({
  user: { type: Schema.Types.ObjectId, ref: "User", required: true },
  department: { type: String },
  accessLevel: { type: Number, default: 1 },
});

const Admin = mongoose.model("Admin", AdminSchema);
module.exports = Admin;


=======================================================================
C:\My-Projects\Fastners-new\server\models\customerModel.js

const mongoose = require("mongoose");
const { Schema } = mongoose;

const CustomerSchema = new Schema({
  user: { type: Schema.Types.ObjectId, ref: "User", required: true },
  shippingAddresses: [
    {
      addressLine1: String,
      addressLine2: String,
      city: String,
      state: String,
      country: String,
      zipCode: String,
    },
  ],
  billingAddress: {
    addressLine1: String,
    addressLine2: String,
    city: String,
    state: String,
    country: String,
    zipCode: String,
  },
  preferredPaymentMethod: { type: String },
});

const Customer = mongoose.model("Customer", CustomerSchema);
module.exports = Customer;


=======================================================================
C:\My-Projects\Fastners-new\server\models\projectModel.js

const mongoose = require("mongoose");
const { Schema } = mongoose;

const ProjectSchema = new Schema(
  {
    customer: { type: Schema.Types.ObjectId, ref: "Customer", required: true },
    user: { type: Schema.Types.ObjectId, ref: "User", required: true },
    supplier: { type: Schema.Types.ObjectId, ref: "Supplier" },
    admin: { type: Schema.Types.ObjectId, ref: "Admin" },
    title: { type: String, required: true },
    description: { type: String },
    requirements: {
      material: String,
      process: String,
      quantity: Number,
      tolerance: String,
      finish: String,
    },
    files: [
      {
        name: String,
        firebaseStorageUrl: String,
        downloadUrl: String,
        fileType: {
          type: String,
          enum: [
            "3DMXL",
            "3MF",
            "DXF",
            "SAT",
            "SLDPRT",
            "STL",
            "STP",
            "STEP",
            "GIF",
            "JPEG",
            "JPG",
            "PNG",
            "PDF",
            "DWG",
            "IGES",
            "POF",
          ],
        },
        category: {
          type: String,
          enum: ["3D_MODEL", "DRAWING", "SPECIFICATION", "IMAGE", "OTHER"],
        },
        uploadedAt: Date,
      },
    ],
    status: {
      type: String,
      enum: [
        "QUOTED",
        "AVAILABLE",
        "IN_PRODUCTION",
        "SHIPPED",
        "DELIVERED",
        "CANCELLED",
      ],
      default: "AVAILABLE",
    },
    deliveryDate: Date,
  },
  { timestamps: true }
);

const Project = mongoose.model("Project", ProjectSchema);
module.exports = Project;


=======================================================================
C:\My-Projects\Fastners-new\server\models\projectUpdateModel.js

const mongoose = require("mongoose");
const { Schema } = mongoose;

const ProjectUpdateSchema = new Schema(
  {
    project: { type: Schema.Types.ObjectId, ref: "Project", required: true },
    supplier: { type: Schema.Types.ObjectId, ref: "Supplier", required: true },
    description: { type: String, required: true },
    status: {
      type: String,
      enum: ["PENDING", "IN_PROGRESS", "COMPLETED"],
      default: "PENDING",
    },
    attachments: [
      {
        name: String,
        firebaseStorageUrl: String,
        downloadUrl: String,
        fileType: {
          type: String,
          enum: [
            "3DMXL",
            "3MF",
            "DXF",
            "SAT",
            "SLDPRT",
            "STL",
            "STP",
            "STEP",
            "GIF",
            "JPEG",
            "JPG",
            "PNG",
            "PDF",
            "DWG",
            "IGES",
            "POF",
          ],
        },
        category: {
          type: String,
          enum: ["3D_MODEL", "DRAWING", "SPECIFICATION", "IMAGE", "OTHER"],
        },
        size: Number, // File size in bytes
        uploadedAt: Date,
      },
    ],
    createdAt: { type: Date, default: Date.now },
  },
  { timestamps: true }
);

module.exports = mongoose.model("ProjectUpdate", ProjectUpdateSchema);


=======================================================================
C:\My-Projects\Fastners-new\server\models\quotationModel.js

const mongoose = require("mongoose");
const { Schema } = mongoose;

const QuotationSchema = new Schema(
  {
    project: {
      type: Schema.Types.ObjectId,
      ref: "Project",
      required: true,
    },
    supplier: {
      type: Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    unitPrice: {
      type: Number,
      required: true,
    },
    quantity: {
      type: Number,
      required: true,
    },
    subtotal: {
      type: Number,
      required: true,
    },
    taxes: {
      type: Number,
      default: 0,
    },
    shippingCost: {
      type: Number,
      default: 0,
    },
    totalPrice: {
      type: Number,
      required: true,
    },
    currency: {
      type: String,
      default: "USD",
    },
    leadTime: {
      type: Number,
      required: true,
    },
    validUntil: {
      type: Date,
      required: true,
    },
    status: {
      type: String,
      enum: ["PENDING", "ACCEPTED", "REJECTED"],
      default: "PENDING",
    },
  },
  { timestamps: true }
);

module.exports = mongoose.model("Quotation", QuotationSchema);


=======================================================================
C:\My-Projects\Fastners-new\server\models\supplierModel.js

const mongoose = require("mongoose");
const { Schema } = mongoose;

const SupplierSchema = new Schema({
  user: { type: Schema.Types.ObjectId, ref: "User", required: true },
  companyName: { type: String },
  companyAddress: { type: String },
  taxId: { type: String },
  manufacturingCapabilities: [String],
  certifications: [String],
  rating: { type: Number, default: 0 },
  totalProjects: { type: Number, default: 0 },
  activeProjects: { type: Number, default: 0 },
  leadTime: { type: Number }, // Average lead time in days
  minimumOrderValue: { type: Number },
});

const Supplier = mongoose.model("Supplier", SupplierSchema);
module.exports = Supplier;


=======================================================================
C:\My-Projects\Fastners-new\server\models\userModel.js

const mongoose = require("mongoose");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const config = require("../config/config");

const UserSchema = new mongoose.Schema(
  {
    email: {
      type: String,
      required: [true, "Please provide an email"],
      unique: true,
      match: [
        /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/,
        "Please provide a valid email",
      ],
    },
    password: {
      type: String,
      required: [true, "Please add a password"],
      minlength: 6,
      select: false,
    },
    role: {
      type: String,
      enum: ["customer", "admin", "supplier"],
    },
    firstName: {
      type: String,
      required: [true, "Please add a first name"],
    },
    lastName: {
      type: String,
      required: [true, "Please add a last name"],
    },
    phoneNumber: String,
    company: String,
    isVerified: {
      type: Boolean,
      default: false,
    },
    otp: {
      code: String,
      expiresAt: Date,
    },
  },
  { timestamps: true }
);

UserSchema.pre("save", async function (next) {
  if (!this.isModified("password")) {
    next();
  }
  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
});

UserSchema.methods.matchPassword = async function (enteredPassword) {
  return await bcrypt.compare(enteredPassword, this.password);
};

UserSchema.methods.getSignedJwtToken = function () {
  return jwt.sign({ id: this._id, role: this.role }, config.JWT_SECRET, {
    expiresIn: config.JWT_EXPIRE,
  });
};

module.exports = mongoose.model("User", UserSchema);


=======================================================================
C:\My-Projects\Fastners-new\server\routes\adminRoutes.js

// adminRoutes.js
const express = require("express");
const router = express.Router();
const {
  getAllUsers,
  getUserById,
  updateUser,
  deleteUser,
  getDashboardStats,
  forwardProjectToSuppliers,
  reviewQuotation,
  getAllSuppliers,
} = require("../controllers/adminControllers");
const { protect, authorize } = require("../middleware/authMiddleware");

router.use(protect);
router.use(authorize("admin"));

router.get("/users", getAllUsers);
router.get("/suppliers", getAllSuppliers);
router.get("/users/:id", getUserById);
router.put("/users/:id", updateUser);
router.delete("/users/:id", deleteUser);
router.get("/dashboard", getDashboardStats);
router.post("/projects/:id/forward", forwardProjectToSuppliers);
router.post("/quotations/review", reviewQuotation);

module.exports = router;


=======================================================================
C:\My-Projects\Fastners-new\server\routes\projectRoutes.js

// projectRoutes.js
const express = require("express");
const router = express.Router();
const {
  createProject,
  getProjects,
  getProjectById,
  updateProject,
  deleteProject,
  forwardToSuppliers,
  getProjectByUserId,
} = require("../controllers/projectControllers");
const { protect, authorize } = require("../middleware/authMiddleware");

router.use(protect);

router.post("/", authorize("customer"), createProject);
router.get("/", getProjects);
router.get(
  "/get-project-by-user-id",
  authorize("customer"),
  getProjectByUserId
);

router.get("/:id", getProjectById);

router.put("/:id", authorize("admin", "supplier"), updateProject);
router.delete("/:id", authorize("admin"), deleteProject);
router.post("/:id/forward", authorize("admin"), forwardToSuppliers);

module.exports = router;


=======================================================================
C:\My-Projects\Fastners-new\server\routes\quotationRoutes.js

// quotationRoutes.js
const express = require("express");
const router = express.Router();
const {
  createQuotation,
  getQuotations,
  getQuotationById,
  updateQuotation,
  acceptQuotation,
} = require("../controllers/quotationControllers");
const { protect, authorize } = require("../middleware/authMiddleware");

router.post("/", protect, authorize("supplier"), createQuotation);
router.get("/", protect, getQuotations);
router.get("/:id", protect, getQuotationById);
router.put("/:id", protect, authorize("admin", "supplier"), updateQuotation);
router.post("/:id/accept", protect, authorize("admin"), acceptQuotation);

module.exports = router;


=======================================================================
C:\My-Projects\Fastners-new\server\routes\supplierRoutes.js

// // supplierRoutes.js
// const express = require("express");
// const router = express.Router();
// const {
//   getSuppliers,
//   getSupplierById,
//   updateSupplier,
//   getSupplierProjects,
//   updateProjectStatus,
// } = require("../controllers/supplierControllers");
// const { protect, authorize } = require("../middleware/authMiddleware");

// router.get("/", protect, authorize("admin"), getSuppliers);
// router.get("/:id", protect, getSupplierById);
// router.put("/:id", protect, authorize("admin", "supplier"), updateSupplier);
// router.get(
//   "/:id/projects",
//   protect,
//   authorize("admin", "supplier"),
//   getSupplierProjects
// );
// router.post(
//   "/update-project",
//   protect,
//   authorize("admin", "supplier"),
//   updateProjectStatus
// );

// module.exports = router;

// supplierRoutes.js
const express = require("express");
const router = express.Router();
const {
  getSuppliers,
  getSupplierById,
  updateSupplier,
  getSupplierProjects,
  updateProjectStatus,
  getSupplierByUserId,
} = require("../controllers/supplierControllers");
const { protect, authorize } = require("../middleware/authMiddleware");

router.get("/", protect, authorize("admin"), getSuppliers);
router.get("/:id", protect, getSupplierById);
router.get("/get-by-user-id", protect, getSupplierByUserId);
router.put("/:id", protect, authorize("admin", "supplier"), updateSupplier);
router.get(
  "/:id/projects",
  protect,
  authorize("admin", "supplier"),
  getSupplierProjects
);
router.post(
  "/update-project",
  protect,
  authorize("admin", "supplier"),
  updateProjectStatus
);

module.exports = router;


=======================================================================
C:\My-Projects\Fastners-new\server\routes\userRoutes.js

// userRoutes.js
const express = require("express");
const router = express.Router();
const {
  register,
  login,
  verifyOTP,
  resendOTP,
  getProfile,
  updateProfile,
  forgotPassword,
  resetPassword,
  updatePassword,
} = require("../controllers/userControllers");
const { protect } = require("../middleware/authMiddleware");

router.post("/register", register);
router.post("/login", login);
router.post("/verify-otp", verifyOTP);
router.post("/resend-otp", resendOTP);
router.post("/forgot-password", forgotPassword);
router.post("/reset-password", resetPassword);

router.get("/profile", protect, getProfile);
router.put("/profile", protect, updateProfile);
router.put("/update-password", protect, updatePassword);

module.exports = router;


=======================================================================
C:\My-Projects\Fastners-new\server\utils\apiFeatures.js

// utils/apiFeatures.js

class APIFeatures {
  constructor(query, queryString) {
    this.query = query;
    this.queryString = queryString;
  }

  filter() {
    const queryObj = { ...this.queryString };
    const excludedFields = ["page", "sort", "limit", "fields", "search"];
    excludedFields.forEach((el) => delete queryObj[el]);

    let queryStr = JSON.stringify(queryObj);
    queryStr = queryStr.replace(/\b(gte|gt|lte|lt)\b/g, (match) => `$${match}`);

    this.query = this.query.find(JSON.parse(queryStr));
    return this;
  }

  sort() {
    if (this.queryString.sort) {
      const sortBy = this.queryString.sort.split(",").join(" ");
      this.query = this.query.sort(sortBy);
    } else {
      this.query = this.query.sort("-createdAt");
    }
    return this;
  }

  limitFields() {
    if (this.queryString.fields) {
      const fields = this.queryString.fields.split(",").join(" ");
      this.query = this.query.select(fields);
    } else {
      this.query = this.query.select("-__v");
    }
    return this;
  }

  paginate() {
    const page = parseInt(this.queryString.page, 10) || 1;
    const limit = parseInt(this.queryString.limit, 10) || 100;
    const skip = (page - 1) * limit;

    this.query = this.query.skip(skip).limit(limit);
    return this;
  }

  search() {
    if (this.queryString.search) {
      const searchFields = [
        "title",
        "description",
        "requirements.material",
        "requirements.process",
      ]; // Add or modify fields as needed
      const searchRegex = new RegExp(this.queryString.search, "i");
      const searchQuery = searchFields.map((field) => ({
        [field]: searchRegex,
      }));
      this.query = this.query.or(searchQuery);
    }
    return this;
  }
}

module.exports = APIFeatures;


=======================================================================
C:\My-Projects\Fastners-new\server\app.js

const express = require("express");
const connectDB = require("./config/dbConnection");
const userRoutes = require("./routes/userRoutes");
const projectRoutes = require("./routes/projectRoutes");
const quotationRoutes = require("./routes/quotationRoutes");
const supplierRoutes = require("./routes/supplierRoutes");
const adminRoutes = require("./routes/adminRoutes");
const cors = require("cors");

const app = express();

// Connect to database
connectDB();

// Use CORS middleware
app.use(cors());
// Middleware
app.use(express.json());

// Routes
app.use("/api/users", userRoutes);
app.use("/api/projects", projectRoutes);
app.use("/api/quotations", quotationRoutes);
app.use("/api/suppliers", supplierRoutes);
app.use("/api/admin", adminRoutes);
// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ success: false, message: "Something went wrong" });
});

const PORT = process.env.PORT || 5000;

app.listen(PORT, () => console.log(`Server running on port ${PORT}`));



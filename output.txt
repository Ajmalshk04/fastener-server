=======================================================================
E:\My-Projects\Fastners-new\server\config\config.js

// config.js
require("dotenv").config();

module.exports = {
  PORT: process.env.PORT || 5000,
  MONGO_URI: process.env.MONGO_URI,
  JWT_SECRET: process.env.JWT_SECRET,
  JWT_EXPIRE: process.env.JWT_EXPIRE || "30d",
  SMTP_HOST: process.env.SMTP_HOST,
  SMTP_PORT: process.env.SMTP_PORT,
  SMTP_USER: process.env.SMTP_USER,
  SMTP_PASS: process.env.SMTP_PASS,
  FROM_EMAIL: process.env.FROM_EMAIL,
};


=======================================================================
E:\My-Projects\Fastners-new\server\config\dbConnection.js

// dbConnection.js
const mongoose = require("mongoose");
const config = require("./config");

const connectDB = async () => {
  try {
    await mongoose.connect(config.MONGO_URI);
    console.log("MongoDB connected");
  } catch (error) {
    console.error("MongoDB connection error:", error);
    process.exit(1);
  }
};

module.exports = connectDB;


=======================================================================
E:\My-Projects\Fastners-new\server\controllers\adminControllers.js

// adminController.js
const User = require("../models/userModel");
const Project = require("../models/projectModel");
const Quotation = require("../models/quotationModel");
const ProjectUpdate = require("../models/projectUpdateModel");
const Supplier = require("../models/supplierModel");
const { sendEmail } = require("../helpers/emailHelper");

exports.getAllUsers = async (req, res) => {
  try {
    const users = await User.find({ role: "customer" });
    res.status(200).json({ success: true, count: users.length, data: users });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};
exports.getAllSuppliers = async (req, res) => {
  try {
    const users = await User.find({ role: "supplier" });
    res.status(200).json({ success: true, count: users.length, data: users });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.getUserById = async (req, res) => {
  try {
    const user = await User.findById(req.params.id);
    if (!user) {
      return res
        .status(404)
        .json({ success: false, message: "User not found" });
    }
    res.status(200).json({ success: true, data: user });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.updateUser = async (req, res) => {
  try {
    const user = await User.findByIdAndUpdate(req.params.id, req.body, {
      new: true,
      runValidators: true,
    });
    if (!user) {
      return res
        .status(404)
        .json({ success: false, message: "User not found" });
    }
    res.status(200).json({ success: true, data: user });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.deleteUser = async (req, res) => {
  try {
    const user = await User.findByIdAndDelete(req.params.id);
    if (!user) {
      return res
        .status(404)
        .json({ success: false, message: "User not found" });
    }
    res.status(200).json({ success: true, message: "User Deleted Successful" });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.getDashboardStats = async (req, res) => {
  try {
    const totalUsers = await User.countDocuments();
    const totalProjects = await Project.countDocuments();
    const totalQuotations = await Quotation.countDocuments();
    const recentProjects = await Project.find().sort("-createdAt").limit(5);
    const recentQuotations = await Quotation.find().sort("-createdAt").limit(5);

    res.status(200).json({
      success: true,
      data: {
        totalUsers,
        totalProjects,
        totalQuotations,
        recentProjects,
        recentQuotations,
      },
    });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.forwardProjectToSuppliers = async (req, res) => {
  try {
    const project = await Project.findById(req.params.id);
    if (!project) {
      return res
        .status(404)
        .json({ success: false, message: "Project not found" });
    }

    const suppliers = await User.find({ role: "supplier" });
    for (let supplier of suppliers) {
      await sendEmail(
        supplier.email,
        "New Project Available for Quotation",
        `A new project "${project.title}" is available for quotation. Please log in to your account to view details and submit your quote.`
      );
    }

    project.status = "SUBMITTED";
    await project.save();

    res.status(200).json({
      success: true,
      message: "Project forwarded to suppliers successfully",
    });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.reviewQuotation = async (req, res) => {
  try {
    const { quotationId, status, adminComment } = req.body;
    const quotation = await Quotation.findById(quotationId);

    if (!quotation) {
      return res
        .status(404)
        .json({ success: false, message: "Quotation not found" });
    }

    quotation.status = status;
    quotation.adminComment = adminComment;
    await quotation.save();

    // Notify supplier about the quotation review
    const supplier = await User.findById(quotation.supplier);
    await sendEmail(
      supplier.email,
      "Quotation Review Update",
      `Your quotation for project "${quotation.project.title}" has been ${status}. Admin comment: ${adminComment}`
    );

    res.status(200).json({
      success: true,
      message: "Quotation reviewed successfully",
      data: quotation,
    });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};




// Get all project updates
exports.getAllProjectUpdates = async (req, res) => {
  try {
    const projectUpdates = await ProjectUpdate.find()
      .populate("project", "title description status")
      .populate("supplier", "companyName");
    res.status(200).json({
      success: true,
      count: projectUpdates.length,
      data: projectUpdates,
    });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

// Get a single project update by ID
exports.getProjectUpdateById = async (req, res) => {
  try {
    const projectUpdate = await ProjectUpdate.findById(req.params.id)
      .populate("project", "title description status")
      .populate("supplier", "companyName");
    if (!projectUpdate) {
      return res.status(404).json({ success: false, message: "Project update not found" });
    }
    res.status(200).json({ success: true, data: projectUpdate });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

// Create a new project update (admin override)
exports.createProjectUpdate = async (req, res) => {
  try {
    const { projectId, supplierId, description, status, completionPercentage } = req.body;

    if (!projectId || !supplierId || !description || !status || completionPercentage === undefined) {
      return res.status(400).json({
        success: false,
        message: "All fields (projectId, supplierId, description, status, completionPercentage) are required",
      });
    }

    const project = await Project.findById(projectId);
    if (!project) {
      return res.status(404).json({ success: false, message: "Project not found" });
    }

    const supplier = await Supplier.findById(supplierId);
    if (!supplier) {
      return res.status(404).json({ success: false, message: "Supplier not found" });
    }

    const projectUpdate = await ProjectUpdate.create({
      project: projectId,
      supplier: supplierId,
      description,
      status,
      completionPercentage,
    });

    // Update project status if applicable
    project.status = status === "COMPLETED" ? "DELIVERED" : "IN_PRODUCTION";
    await project.save();

    // Notify supplier and customer
    const supplierUser = await User.findById(supplier.user);
    const customer = await User.findById(project.customer);
    const recipients = [supplierUser, customer].filter(Boolean);
    for (let recipient of recipients) {
      await sendEmail(
        recipient.email,
        "Admin Project Update",
        `Admin updated project "${project.title}" to "${status}". Description: ${description}, Completion: ${completionPercentage}%`
      );
    }

    res.status(201).json({ success: true, data: projectUpdate });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

// Update a project update
exports.updateProjectUpdate = async (req, res) => {
  try {
    const { description, status, completionPercentage } = req.body;

    const projectUpdate = await ProjectUpdate.findById(req.params.id);
    if (!projectUpdate) {
      return res.status(404).json({ success: false, message: "Project update not found" });
    }

    projectUpdate.description = description || projectUpdate.description;
    projectUpdate.status = status || projectUpdate.status;
    projectUpdate.completionPercentage = completionPercentage !== undefined ? completionPercentage : projectUpdate.completionPercentage;
    await projectUpdate.save();

    // Update project status if changed
    const project = await Project.findById(projectUpdate.project);
    if (status && project.status !== (status === "COMPLETED" ? "DELIVERED" : "IN_PRODUCTION")) {
      project.status = status === "COMPLETED" ? "DELIVERED" : "IN_PRODUCTION";
      await project.save();
    }

    res.status(200).json({ success: true, data: projectUpdate });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

// Delete a project update
exports.deleteProjectUpdate = async (req, res) => {
  try {
    const projectUpdate = await ProjectUpdate.findByIdAndDelete(req.params.id);
    if (!projectUpdate) {
      return res.status(404).json({ success: false, message: "Project update not found" });
    }
    res.status(200).json({ success: true, message: "Project update deleted successfully" });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

=======================================================================
E:\My-Projects\Fastners-new\server\controllers\projectControllers.js

// projectController.js
const Project = require("../models/projectModel");
const User = require("../models/userModel");
const { sendEmail } = require("../helpers/emailHelper");
const APIFeatures = require("../utils/apiFeatures");

exports.createProject = async (req, res) => {
  try {
    const project = await Project.create({
      ...req.body,
      user: req.user._id,
    });

    // Notify admin about new project
    // const admins = await User.find({ role: "admin" });
    // for (let admin of admins) {
    //   await sendEmail(
    //     admin.email,
    //     "New Project Created",
    //     `A new project "${project.title}" has been created and needs your attention.`
    //   );
    // }

    res.status(201).json({ success: true, data: project });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

// exports.getProjects = async (req, res) => {
//   try {
//     const features = new APIFeatures(
//       Project.find(),
//       req.query
//     )
//       .search()
//       .filter()
//       .sort()
//       .limitFields()
//       .paginate();

//     const projects = await features.query;

//     res
//       .status(200)
//       .json({ success: true, count: projects.length, data: projects });
//   } catch (error) {
//     res.status(400).json({ success: false, error: error.message });
//   }
// };

exports.getProjects = async (req, res) => {
  try {
    let query = Project.find();

    if (req.user.role === 'supplier') {
      // Show only projects open for bidding
      query = query.where({ status: 'AVAILABLE' });
    } else if (req.user.role === 'customer') {
      // Show customer's projects
      query = query.where({ user: req.user._id });
    }

    const features = new APIFeatures(query, req.query)
      .search()
      .filter()
      .sort()
      .limitFields()
      .paginate();

    const projects = await features.query.populate('supplier');
    res.status(200).json({ success: true, data: projects });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.getProjectById = async (req, res) => {
  try {
    const project = await Project.findById(req.params.id).populate("customer user supplier");
    if (!project) {
      return res
        .status(404)
        .json({ success: false, message: "Project not found" });
    }
    res.status(200).json({ success: true, data: project });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.getProjectByUserId = async (req, res) => {
  try {
    console.log("Project-MONGOID", req.user);

    const project = await Project.find({ user: req.user._id }).populate(
      "customer"
    );
    if (!project) {
      return res
        .status(404)
        .json({ success: false, message: "Project not found" });
    }
    res.status(200).json({ success: true, data: project });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.updateProject = async (req, res) => {
  try {
    const project = await Project.findByIdAndUpdate(req.params.id, req.body, {
      new: true,
      runValidators: true,
    });
    if (!project) {
      return res
        .status(404)
        .json({ success: false, message: "Project not found" });
    }
    res.status(200).json({ success: true, data: project });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.deleteProject = async (req, res) => {
  try {
    const project = await Project.findByIdAndDelete(req.params.id);
    if (!project) {
      return res
        .status(404)
        .json({ success: false, message: "Project not found" });
    }
    res.status(200).json({ success: true, data: "Project Deleted Successful" });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.forwardToSuppliers = async (req, res) => {
  try {
    const project = await Project.findById(req.params.id);
    if (!project) {
      return res
        .status(404)
        .json({ success: false, message: "Project not found" });
    }

    const suppliers = await User.find({ role: "supplier" });
    for (let supplier of suppliers) {
      await sendEmail(
        supplier.email,
        "New Project Opportunity",
        `A new project "${project.title}" is available for quotation. Please check your dashboard for details.`
      );
    }

    project.status = "SUBMITTED";
    await project.save();

    res
      .status(200)
      .json({ success: true, message: "Project forwarded to suppliers" });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};


=======================================================================
E:\My-Projects\Fastners-new\server\controllers\quotationControllers.js

// quotationController.js
const Quotation = require("../models/quotationModel");
const Project = require("../models/projectModel");
const User = require("../models/userModel");
const { sendEmail } = require("../helpers/emailHelper");
const APIFeatures = require("../utils/apiFeatures");
const Supplier = require("../models/supplierModel");

exports.createQuotation = async (req, res) => {
  try {
    const { 
      unitPrice, 
      quantity, 
      taxes, 
      shippingCost, 
      leadTime, 
      validUntil 
    } = req.body;

    const user = await User.findOne({ _id: req.user.id });
    if (!user) {
      return res.status(400).json({ success: false, message: "Supplier profile not found" });
    }

    const supplier = await Supplier.findOne({ user: req.user.id });
    if (!supplier) {
      return res.status(400).json({ success: false, message: "Supplier profile not found" });
    }

    const quotation = await Quotation.create({
      project: req.params.projectId,
      supplier: supplier._id, // Use supplier._id instead of req.user.id
      unitPrice: parseFloat(unitPrice),
      quantity: parseInt(quantity),
      subtotal: parseFloat(unitPrice) * parseInt(quantity),
      taxes: parseFloat(taxes || 0),
      shippingCost: parseFloat(shippingCost || 0),
      totalPrice: parseFloat(unitPrice) * parseInt(quantity) + parseFloat(taxes || 0) + parseFloat(shippingCost || 0),
      leadTime: parseInt(leadTime),
      validUntil: new Date(validUntil),
      status: "PENDING",
    });

    // Notify Admin about new quotation
    const admins = await User.find({ role: "admin" });
    for (let admin of admins) {
      await sendEmail(
        admin.email,
        "New Quotation Received",
        `A new quotation has been submitted for project "${quotation.project.title}".`
      );
    }

    res.status(201).json({ success: true, data: quotation });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.getQuotations = async (req, res) => {
  try {
    let query = Quotation.find();

    // Role-based filtering
    if (req.user.role === "supplier") {
      const supplier = await Supplier.findOne({ user: req.user.id });
      if (!supplier) {
        return res.status(404).json({
          success: false,
          message: "Supplier profile not found",
        });
      }
      query = query.where({ supplier: supplier._id });
    }
    // No additional filtering for admin or customer roles; admins see all quotations

    const features = new APIFeatures(query, req.query)
      .filter()
      .sort()
      .limitFields()
      .paginate();

    const quotations = await features.query.populate([
      {
        path: "project",
        select: "title description status createdAt",
        populate: {
          path: "customer",
          select: "companyName",
        },
      },
      {
        path: "supplier",
        select: "companyName certifications",
        populate: {
          path: "user",
          select: "firstName lastName email",
        },
      },
    ]);

    res.status(200).json({
      success: true,
      count: quotations.length,
      data: quotations,
    });
  } catch (error) {
    res.status(400).json({
      success: false,
      error: error.message,
    });
  }
};

exports.getQuotationById = async (req, res) => {
  try {
    const quotation = await Quotation.findById(req.params.id);
    if (!quotation) {
      return res
        .status(404)
        .json({ success: false, message: "Quotation not found" });
    }
    res.status(200).json({ success: true, data: quotation });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.updateQuotationStatus = async (req, res) => {
  try {
    const { status } = req.body; // status should be either 'ACCEPTED' or 'REJECTED'
    const quotation = await Quotation.findById(req.params.id).populate("project");
    if (!quotation) {
      return res.status(404).json({ success: false, message: "Quotation not found" });
    }

    if (status === "ACCEPTED") {
      // Update quotation status
      quotation.status = "ACCEPTED";
      await quotation.save();

      // Update project status and assign supplier
      const project = await Project.findById(quotation.project._id);
      if (!project) {
        return res.status(404).json({ success: false, message: "Project not found" });
      }
      project.status = "IN_PRODUCTION";
      project.supplier = quotation.supplier; // Assign supplier to project
      await project.save();

      // Notify Supplier about acceptance (if supplier exists)
      const supplier = quotation.supplier ? await User.findById(quotation.supplier) : null;
      if (supplier) {
        await sendEmail(
          supplier.email,
          "Quotation Accepted",
          `Your quotation for project "${project.title}" has been accepted. Production will begin soon.`
        );
      } else {
        console.warn(`No supplier found for quotation ${quotation._id}`);
      }

      // Notify Customer about acceptance (if customer exists)
      const customer = project.customer ? await User.findById(project.customer) : null;
      if (customer) {
        await sendEmail(
          customer.email,
          "Project Update",
          `A supplier has been selected for your project "${project.title}". Production will begin soon.`
        );
      } else {
        console.warn(`No customer found for project ${project._id}`);
      }
    } else if (status === "REJECTED") {
      quotation.status = "REJECTED";
      await quotation.save();

      const supplier = quotation.supplier ? await User.findById(quotation.supplier) : null;
      if (supplier) {
        await sendEmail(
          supplier.email,
          "Quotation Rejected",
          `Your quotation for project "${quotation.project.title}" has been rejected.`
        );
      } else {
        console.warn(`No supplier found for quotation ${quotation._id}`);
      }
    }

    res.status(200).json({
      success: true,
      message: status === "ACCEPTED" ? "Quotation accepted and project updated" : "Quotation rejected",
    });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.acceptQuotation = async (req, res) => {
  try {
    const quotation = await Quotation.findById(req.params.id);
    if (!quotation) {
      return res
        .status(404)
        .json({ success: false, message: "Quotation not found" });
    }

    quotation.status = "ACCEPTED";
    await quotation.save();

    const project = await Project.findById(quotation.project);
    project.supplier = quotation.supplier;
    project.status = "IN_PRODUCTION";
    await project.save();

    // Notify supplier about accepted quotation
    const supplier = await User.findById(quotation.supplier);
    await sendEmail(
      supplier.email,
      "Quotation Accepted",
      `Your quotation for project "${project.title}" has been accepted.`
    );

    // Notify customer about accepted quotation
    const customer = await User.findById(project.customer);
    await sendEmail(
      customer.email,
      "Project Update",
      `A supplier has been selected for your project "${project.title}". Production will begin soon.`
    );

    res.status(200).json({
      success: true,
      message: "Quotation accepted and project updated",
    });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};


=======================================================================
E:\My-Projects\Fastners-new\server\controllers\supplierControllers.js

// supplierController.js
const Supplier = require("../models/supplierModel");
const User = require("../models/userModel");
const Project = require("../models/projectModel");
const APIFeatures = require("../utils/apiFeatures");
const ProjectUpdate = require("../models/projectUpdateModel");
const quotationModel = require("../models/quotationModel");
const { sendEmail } = require("../helpers/emailHelper");

exports.getSuppliers = async (req, res) => {
  try {
    const features = new APIFeatures(Supplier.find(), req.query)
      .filter()
      .sort()
      .limitFields()
      .paginate();

    const suppliers = await features.query;

    res
      .status(200)
      .json({ success: true, count: suppliers.length, data: suppliers });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.getSupplierById = async (req, res) => {
  try {
    const supplier = await Supplier.findById(req.params.id).populate(
      "user",
      "firstName lastName email"
    );
    if (!supplier) {
      return res
        .status(404)
        .json({ success: false, message: "Supplier not found" });
    }
    res.status(200).json({ success: true, data: supplier });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};
exports.getSupplierByUserId = async (req, res) => {
  try {

    console.log(req.user._id);
const user = req.user._id;


    if (!user || !user.id) {
      return res
        .status(400)
        .json({ success: false, message: "User ID is not valid" });
    }

    const supplier = await Supplier.findOne({ user }).populate(
      "user",
      "firstName lastName email"
    );
    if (!supplier) {
      return res
        .status(404)
        .json({ success: false, message: "Supplier not found" });
    }
    res.status(200).json({ success: true, data: supplier });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.updateSupplier = async (req, res) => {
  try {
    let updateData = req.body;

    // If competencies are being updated, ensure they're added to manufacturingCapabilities
    if (req.body.competencies) {
      updateData = {
        ...req.body,
        manufacturingCapabilities: req.body.competencies,
      };
      delete updateData.competencies; // Remove the temporary competencies field
    }

    const supplier = await Supplier.findByIdAndUpdate(
      req.params.id,
      updateData,
      {
        new: true,
        runValidators: true,
      }
    );

    if (!supplier) {
      return res
        .status(404)
        .json({ success: false, message: "Supplier not found" });
    }
    res.status(200).json({ success: true, data: supplier });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.getSupplierProjects = async (req, res) => {
  try {
    const supplierId = req.params.id;
    const supplier = await Supplier.findById(supplierId);

    if (!supplier) {
      return res
        .status(404)
        .json({ success: false, message: "Supplier not found" });
    }

    // Check if the logged-in user is the supplier or an admin
    if (req.user.role !== "admin" && supplier.user.toString() !== req.user.id) {
      return res.status(403).json({
        success: false,
        message: "Not authorized to view these projects",
      });
    }

    const features = new APIFeatures(
      Project.find({ supplier: supplierId }),
      req.query
    )
      .search()
      .filter()
      .sort()
      .limitFields()
      .paginate();

    const projects = await features.query;

    res.status(200).json({
      success: true,
      count: projects.length,
      data: projects,
    });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.getSupplierOrders = async (req, res) => {
  try {
    const supplier = await Supplier.findOne({ user: req.user.id });
    if (!supplier) {
      return res.status(404).json({ success: false, message: "Supplier profile not found" });
    }

    const orders = await quotationModel.find({ 
      supplier: supplier._id, 
      status: "ACCEPTED" 
    }).populate({
      path: "project",
      select: "title description status createdAt",
    });

    res.status(200).json({
      success: true,
      count: orders.length,
      data: orders,
    });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};



exports.updateProjectStatus = async (req, res) => {
  try {
    const { projectId, status, description, completionPercentage } = req.body;

    // Validate required fields
    if (!projectId || !status || !description || completionPercentage === undefined) {
      return res.status(400).json({
        success: false,
        message: "Project ID, status, description, and completion percentage are required",
      });
    }

    // Find the supplier
    const supplier = await Supplier.findOne({ user: req.user.id });
    if (!supplier) {
      return res.status(404).json({
        success: false,
        message: "Supplier profile not found",
      });
    }

    // Verify the project exists and belongs to the supplier
    const project = await Project.findOne({ _id: projectId, supplier: supplier._id });
    if (!project) {
      return res.status(403).json({
        success: false,
        message: "Project not found or not assigned to this supplier",
      });
    }

    // Create a new project update
    const projectUpdate = await ProjectUpdate.create({
      project: projectId,
      supplier: supplier._id,
      description,
      status,
      completionPercentage,
    });

    // Update the project status in the Project model
    project.status = status === "COMPLETED" ? "DELIVERED" : "IN_PRODUCTION"; // Map to Project model statuses
    await project.save();

    // Notify customer and admin
    const customer = await User.findById(project.customer);
    const admins = await User.find({ role: "admin" });
    const recipients = [customer, ...admins].filter(Boolean);

    for (let recipient of recipients) {
      await sendEmail(
        recipient.email,
        "Project Status Update",
        `The project "${project.title}" has been updated to "${status}" by the supplier. Description: ${description}, Completion: ${completionPercentage}%`
      );
    }

    res.status(200).json({
      success: true,
      message: "Project status updated successfully",
      data: projectUpdate,
    });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.submitProjectUpdate = async (req, res) => {
  try {
    const { projectId, status, description, completionPercentage } = req.body;

    if (!completionPercentage) {
      return res.status(400).json({ success: false, message: "Completion percentage is required" });
    }

    const project = await Project.findOne({ _id: projectId, supplier: req.user._id });
    if (!project) {
      return res.status(404).json({ success: false, message: "Project not found or unauthorized" });
    }

    // Create a new project update
    const update = await ProjectUpdate.create({
      project: projectId,
      supplier: req.user._id,
      status,
      description,
      completionPercentage,
    });

    // Update project status if necessary
    if (status !== project.status) {
      project.status = status;
      await project.save();
    }

    // Notify admin & customer
    const recipients = [
      ...(await User.find({ role: "admin" })),
      await User.findById(project.customer),
    ];

    for (let recipient of recipients) {
      await sendEmail(recipient.email, "Project Update", `Project "${project.title}" updated: ${description}`);
    }

    res.status(201).json({
      success: true,
      message: "Project update submitted successfully",
      data: update,
    });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};


exports.updateCapabilities = async (req, res) => {
  try {
    const supplierId = req.user.id; // Extract supplier's user ID from request
    console.log("supplierId", supplierId);

    const { addCapabilities, removeCapabilities } = req.body;

    if (!addCapabilities && !removeCapabilities) {
      return res.status(400).json({ message: "Provide capabilities to add or remove" });
    }

    // Step 1: Fetch Supplier's Current Capabilities
    const supplier = await Supplier.findOne({ user: supplierId });
    if (!supplier) return res.status(404).json({ message: "Supplier not found" });

    const currentCapabilities = supplier.manufacturingCapabilities || [];

    // Step 2: Check existence of `addCapabilities`
    const existingAdd = [];
    const newAdd = [];
    if (addCapabilities && Array.isArray(addCapabilities)) {
      addCapabilities.forEach(capability => {
        if (currentCapabilities.includes(capability)) {
          existingAdd.push(capability); // Already exists
        } else {
          newAdd.push(capability); // Needs to be added
        }
      });
    }

    // Step 3: Check existence of `removeCapabilities`
    const existingRemove = [];
    const nonExistingRemove = [];
    if (removeCapabilities && Array.isArray(removeCapabilities)) {
      removeCapabilities.forEach(capability => {
        if (currentCapabilities.includes(capability)) {
          existingRemove.push(capability); // Exists and can be removed
        } else {
          nonExistingRemove.push(capability); // Doesn't exist
        }
      });
    }

    let updatedSupplier = supplier; // Store updated supplier data

    // Step 4: Add new capabilities (separate update)
    if (newAdd.length > 0) {
      updatedSupplier = await Supplier.findOneAndUpdate(
        { user: supplierId },
        { $addToSet: { manufacturingCapabilities: { $each: newAdd } } },
        { new: true }
      );
    }

    // Step 5: Remove existing capabilities (separate update)
    if (existingRemove.length > 0) {
      updatedSupplier = await Supplier.findOneAndUpdate(
        { user: supplierId },
        { $pull: { manufacturingCapabilities: { $in: existingRemove } } },
        { new: true }
      );
    }

    // Step 6: Return response
    res.json({
      message: "Capabilities updated successfully",
      existingAdd,
      newAdd,
      existingRemove,
      nonExistingRemove,
      supplier: updatedSupplier,
    });

  } catch (error) {
    res.status(500).json({ message: "Server error", error });
  }
};

exports.getManufacturingCapabilities = async (req, res) => {
  try {
    const supplierId = req.user.id; // Extract supplier's user ID from request
console.log("supplierId", supplierId);

    // Find supplier by user ID
    const supplier = await Supplier.findOne({ user: supplierId }).select("manufacturingCapabilities");
    
    if (!supplier) {
      return res.status(404).json({ message: "Supplier not found" });
    }

    res.json({ manufacturingCapabilities: supplier.manufacturingCapabilities });
  } catch (error) {
    res.status(500).json({ message: "Server error", error });
  }
};

=======================================================================
E:\My-Projects\Fastners-new\server\controllers\userControllers.js

// userController.js
const User = require("../models/userModel");
const Customer = require("../models/customerModel");
const Supplier = require("../models/supplierModel");
const Admin = require("../models/adminModel");
const { sendEmail } = require("../helpers/emailHelper");
const { generateOTP } = require("../helpers/otpHelper");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

exports.register = async (req, res) => {
  try {
    const { email, password, firstName, lastName, role, company, phoneNumber } =
      req.body;

    const user = await User.create({
      email,
      password,
      firstName,
      lastName,
      role,
      company,
      phoneNumber,
    });

    const otp = generateOTP();
    user.otp = {
      code: otp,
      expiresAt: Date.now() + 10 * 60 * 1000, // OTP valid for 10 minutes
    };
    await user.save();

    // Create role-specific profile
    if (role === "customer") {
      await Customer.create({ user: user._id });
    } else if (role === "supplier") {
      await Supplier.create({ user: user._id, companyName: company });
    } else if (role === "admin") {
      await Admin.create({ user: user._id });
    }

    await sendEmail(email, "Verify Your Account", `Your OTP is: ${otp}`);
    res.status(201).json({
      success: true,
      message: "User registered. Please check your email for OTP.",
    });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;
    const user = await User.findOne({ email }).select("+password");

    if (!user.isVerified) {
      return res
        .status(401)
        .json({ success: false, message: "Please verify your account first" });
    }

    if (!user || !(await user.matchPassword(password))) {
      return res
        .status(401)
        .json({ success: false, message: "Invalid credentials" });
    }

    const token = user.getSignedJwtToken();
    res.status(200).json({ success: true, token });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.verifyOTP = async (req, res) => {
  try {
    const { email, otp } = req.body;
    const user = await User.findOne({ email });
    if (!user) {
      return res
        .status(404)
        .json({ success: false, message: "User not found" });
    }
    if (user.otp.code !== otp || user.otp.expiresAt < Date.now()) {
      return res
        .status(400)
        .json({ success: false, message: "Invalid or expired OTP" });
    }
    user.isVerified = true;
    user.otp = undefined;
    await user.save();
    res
      .status(200)
      .json({ success: true, message: "Account verified successfully" });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.resendOTP = async (req, res) => {
  try {
    const { email } = req.body;
    const user = await User.findOne({ email });
    if (!user) {
      return res
        .status(404)
        .json({ success: false, message: "User not found" });
    }
    const otp = generateOTP();
    user.otp = {
      code: otp,
      expiresAt: Date.now() + 10 * 60 * 1000,
    };
    await user.save();
    await sendEmail(
      email,
      "New OTP for Account Verification",
      `Your new OTP is: ${otp}`
    );
    res
      .status(200)
      .json({ success: true, message: "New OTP sent to your email" });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.getProfile = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    let profile;
    if (user.role === "customer") {
      profile = await Customer.findOne({ user: user._id });
    } else if (user.role === "supplier") {
      profile = await Supplier.findOne({ user: user._id });
    } else if (user.role === "admin") {
      profile = await Admin.findOne({ user: user._id });
    }
    res.status(200).json({ success: true, data: { user, profile } });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.updateProfile = async (req, res) => {
  try {
    const user = await User.findByIdAndUpdate(req.user.id, req.body, {
      new: true,
      runValidators: true,
    });
    let profile;
    if (user.role === "customer") {
      profile = await Customer.findOneAndUpdate({ user: user._id }, req.body, {
        new: true,
        runValidators: true,
      });
    } else if (user.role === "supplier") {
      profile = await Supplier.findOneAndUpdate({ user: user._id }, req.body, {
        new: true,
        runValidators: true,
      });
    } else if (user.role === "admin") {
      profile = await Admin.findOneAndUpdate({ user: user._id }, req.body, {
        new: true,
        runValidators: true,
      });
    }
    res.status(200).json({ success: true, data: { user, profile } });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

exports.updatePassword = async (req, res) => {
  try {
    const { oldPassword, newPassword } = req.body;
    console.log(oldPassword, newPassword);

    const user = await User.findById(req.user.id).select("+password");
    console.log(user);

    if (!user) {
      return res
        .status(404)
        .json({ success: false, message: "User not found" });
    }
    const isMatch = await bcrypt.compare(oldPassword, user.password);
    if (!isMatch) {
      return res
        .status(401)
        .json({ success: false, message: "Incorrect old password" });
    }
    console.log(newPassword);

    user.password = newPassword;
    await user.save();
    res
      .status(200)
      .json({ success: true, message: "Password updated successfully" });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Internal server error",
      error: error.message,
    });
  }
};

// exports.forgotPassword = async (req, res) => {
//   try {
//     const { email } = req.body;
//     const user = await User.findOne({ email });
//     if (!user) {
//       return res
//         .status(404)
//         .json({ success: false, message: "User not found" });
//     }
//     const resetToken = jwt.sign({ id: user._id }, process.env.RESET_SECRET, {
//       expiresIn: "1h",
//     });
//     const resetLink = `http://localhost:5173/auth/reset-password?token=${resetToken}`;

//     const resetlink = `
//       <div style="font-family: Arial, sans-serif; max-width: 600px; margin: auto; padding: 20px; border: 1px solid #dddddd; border-radius: 10px;">
//         <h2 style="color: #333;">Password Reset Request</h2>
//         <p style="color: #555;">
//           You requested to reset your password. Please use the following link to reset it:
//         </p>
//         <div style="text-align: center; margin: 20px 0;">
//           <a href="${resetLink}" style="font-size: 18px; font-weight: bold; color: #007BFF;">Reset Password</a>
//         </div>
//         <p style="color: #555;">
//           If you did not request this password reset, please ignore this email.
//         </p>
//         <p style="color: #999; font-size: 12px;">
//           Best regards,<br>
//           Your Service Team
//         </p>
//       </div>
//     `;

//     await sendEmail(
//       email,
//       "Password Reset Request",
//       "Please use the following link to reset your password: [link]",
//       resetlink
//     );
//     res
//       .status(200)
//       .json({ success: true, message: "Password reset link sent to email" });
//   } catch (error) {
//     res.status(500).json({
//       success: false,
//       message: "Internal server error",
//       error: error.message,
//     });
//   }
// };

exports.forgotPassword = async (req, res) => {
  try {
    const { email } = req.body;
    const user = await User.findOne({ email });

    if (!user) {
      return res
        .status(404)
        .json({ success: false, message: "User not found" });
    }

    const resetToken = jwt.sign({ id: user._id }, process.env.RESET_SECRET, {
      expiresIn: "1h",
    });
    const resetLink = `http://localhost:5173/auth/reset-password?token=${resetToken}`; // Replace with your frontend URL

    // Define the HTML email content
    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: auto; padding: 20px; border: 1px solid #dddddd; border-radius: 10px;">
        <h2 style="color: #333;">Password Reset Request</h2>
        <p style="color: #555;">
          You requested to reset your password. Please use the following link to reset it:
        </p>
        <div style="text-align: center; margin: 20px 0;">
          <a href="${resetLink}" style="font-size: 18px; font-weight: bold; color: #007BFF;">Reset Password</a>
        </div>
        <p style="color: #555;">
          If you did not request this password reset, please ignore this email.
        </p>
        <p style="color: #999; font-size: 12px;">
          Best regards,<br>
          Your Service Team
        </p>
      </div>
    `;

    console.log("Sending email with HTML content..."); // Debugging line

    // Send the email with HTML content
    await sendEmail(email, "Password Reset Request", html);

    res
      .status(200)
      .json({ success: true, message: "Password reset link sent to email" });
  } catch (error) {
    console.error("Error in forgotPassword function:", error); // Debugging line
    res.status(500).json({
      success: false,
      message: "Internal server error",
      error: error.message,
    });
  }
};

exports.resetPassword = async (req, res) => {
  try {
    const { token, newPassword } = req.body;
    const decoded = jwt.verify(token, process.env.RESET_SECRET);
    const user = await User.findById(decoded.id).select("+password");
    if (!user) {
      return res
        .status(404)
        .json({ success: false, message: "User not found" });
    }
    user.password = await bcrypt.hash(newPassword, 10);
    await user.save();
    res
      .status(200)
      .json({ success: true, message: "Password reset successfully" });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: "Internal server error",
      error: error.message,
    });
  }
};


=======================================================================
E:\My-Projects\Fastners-new\server\helpers\emailHelper.js

// emailHelper.js
const nodemailer = require("nodemailer");
const config = require("../config/config");

exports.sendEmail = async (to, subject, html) => {
  const transporter = nodemailer.createTransport({
    // host: config.SMTP_HOST,
    // port: config.SMTP_PORT,
    service: "gmail",
    auth: {
      user: config.SMTP_USER,
      pass: config.SMTP_PASS,
    },
  });

  await transporter.sendMail({
    from: config.FROM_EMAIL,
    to,
    subject,
    html,
  });
};

// otpHelper.js
exports.generateOTP = () => {
  return Math.floor(100000 + Math.random() * 900000).toString();
};


=======================================================================
E:\My-Projects\Fastners-new\server\helpers\otpHelper.js

const crypto = require("node:crypto");

const generateOTP = () => {
  const otp = crypto.randomInt(100000, 999999).toString();
  return otp;
};

module.exports = { generateOTP };


=======================================================================
E:\My-Projects\Fastners-new\server\middleware\authMiddleware.js

// authMiddleware.js
const jwt = require("jsonwebtoken");
const User = require("../models/userModel");
const config = require("../config/config");

exports.protect = async (req, res, next) => {
  let token;
  if (
    req.headers.authorization &&
    req.headers.authorization.startsWith("Bearer")
  ) {
    token = req.headers.authorization.split(" ")[1];
  }
  if (!token) {
    return res
      .status(401)
      .json({ success: false, message: "Not authorized to access this route" });
  }
  try {
    const decoded = jwt.verify(token, config.JWT_SECRET);
    req.user = await User.findById(decoded.id);
    // console.log("User",req.user);
    
    if (!req.user) {
      return res.status(401).json({
        success: false,
        message: "Not authorized to access this route",
      });
    }
    next();
  } catch (error) {
    return res
      .status(401)
      .json({ success: false, message: "Not authorized to access this route" });
  }
};

exports.authorize = (...roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({
        success: false,
        message: "User role is not authorized to access this route",
      });
    }
    next();
  };
};


=======================================================================
E:\My-Projects\Fastners-new\server\models\adminModel.js

const mongoose = require("mongoose");
const { Schema } = mongoose;

const AdminSchema = new Schema({
  user: { type: Schema.Types.ObjectId, ref: "User", required: true },
  department: { type: String },
  accessLevel: { type: Number, default: 1 },
});

const Admin = mongoose.model("Admin", AdminSchema);
module.exports = Admin;


=======================================================================
E:\My-Projects\Fastners-new\server\models\customerModel.js

const mongoose = require("mongoose");
const { Schema } = mongoose;

const CustomerSchema = new Schema({
  user: { type: Schema.Types.ObjectId, ref: "User", required: true },
  shippingAddresses: [
    {
      addressLine1: String,
      addressLine2: String,
      city: String,
      state: String,
      country: String,
      zipCode: String,
    },
  ],
  billingAddress: {
    addressLine1: String,
    addressLine2: String,
    city: String,
    state: String,
    country: String,
    zipCode: String,
  },
  preferredPaymentMethod: { type: String },
});

const Customer = mongoose.model("Customer", CustomerSchema);
module.exports = Customer;


=======================================================================
E:\My-Projects\Fastners-new\server\models\projectModel.js

const mongoose = require("mongoose");
const { Schema } = mongoose;

const ProjectSchema = new Schema(
  {
    customer: { type: Schema.Types.ObjectId, ref: "Customer", required: true },
    user: { type: Schema.Types.ObjectId, ref: "User", required: true },
    supplier: { type: Schema.Types.ObjectId, ref: "Supplier" },
    admin: { type: Schema.Types.ObjectId, ref: "Admin" },
    title: { type: String, required: true },
    description: { type: String },
    requirements: {
      material: String,
      process: String,
      quantity: Number,
      tolerance: String,
      finish: String,
    },
    files: [
      {
        name: String,
        firebaseStorageUrl: String,
        downloadUrl: String,
        fileType: {
          type: String,
          enum: [
            "3DMXL",
            "3MF",
            "DXF",
            "SAT",
            "SLDPRT",
            "STL",
            "STP",
            "STEP",
            "GIF",
            "JPEG",
            "JPG",
            "PNG",
            "PDF",
            "DWG",
            "IGES",
            "POF",
          ],
        },
        category: {
          type: String,
          enum: ["3D_MODEL", "DRAWING", "SPECIFICATION", "IMAGE", "OTHER"],
        },
        uploadedAt: Date,
      },
    ],
    status: {
      type: String,
      enum: [
        "AVAILABLE",
        "IN_PRODUCTION",
        "SHIPPED",
        "DELIVERED",
        "CANCELLED",
      ],
      default: "AVAILABLE",
    },
    deliveryDate: Date,
  },
  { timestamps: true }
);

const Project = mongoose.model("Project", ProjectSchema);
module.exports = Project;


=======================================================================
E:\My-Projects\Fastners-new\server\models\projectUpdateModel.js

const mongoose = require("mongoose");
const { Schema } = mongoose;

const ProjectUpdateSchema = new Schema(
  {
    project: { type: Schema.Types.ObjectId, ref: "Project", required: true },
    supplier: { type: Schema.Types.ObjectId, ref: "Supplier", required: true },
    description: { type: String, required: true },
    status: {
      type: String,
      enum: ["PENDING", "IN_PROGRESS", "COMPLETED"],
      default: "PENDING",
    },
    completionPercentage: { type: Number, required: true },
    attachments: [
      {
        name: String,
        firebaseStorageUrl: String,
        downloadUrl: String,
        fileType: {
          type: String,
          enum: [
            "3DMXL",
            "3MF",
            "DXF",
            "SAT",
            "SLDPRT",
            "STL",
            "STP",
            "STEP",
            "GIF",
            "JPEG",
            "JPG",
            "PNG",
            "PDF",
            "DWG",
            "IGES",
            "POF",
          ],
        },
        category: {
          type: String,
          enum: ["3D_MODEL", "DRAWING", "SPECIFICATION", "IMAGE", "OTHER"],
        },
        size: Number, // File size in bytes
        uploadedAt: Date,
      },
    ],
  },
  { timestamps: true }
);

module.exports = mongoose.model("ProjectUpdate", ProjectUpdateSchema);

=======================================================================
E:\My-Projects\Fastners-new\server\models\quotationModel.js

const mongoose = require("mongoose");
const { Schema } = mongoose;

const QuotationSchema = new Schema(
  {
    project: {
      type: Schema.Types.ObjectId,
      ref: "Project",
      required: true,
    },
    supplier: {
      type: Schema.Types.ObjectId,
      ref: "Supplier",
      required: true,
    },
    unitPrice: {
      type: Number,
      required: true,
    },
    quantity: {
      type: Number,
      required: true,
    },
    subtotal: {
      type: Number,
      required: true,
    },
    taxes: {
      type: Number,
      default: 0,
    },
    shippingCost: {
      type: Number,
      default: 0,
    },
    totalPrice: {
      type: Number,
      required: true,
    },
    currency: {
      type: String,
      default: "USD",
    },
    leadTime: {
      type: Number,
      required: true,
    },
    validUntil: {
      type: Date,
      required: true,
    },
    status: {
      type: String,
      enum: ["PENDING", "ACCEPTED", "REJECTED"],
      default: "PENDING",
    },
  },
  { timestamps: true }
);

QuotationSchema.index({ project: 1, supplier: 1 }, { unique: true });
module.exports = mongoose.model("Quotation", QuotationSchema);


=======================================================================
E:\My-Projects\Fastners-new\server\models\supplierModel.js

const mongoose = require("mongoose");
const { Schema } = mongoose;

const SupplierSchema = new Schema({
  user: { type: Schema.Types.ObjectId, ref: "User", required: true },
  companyName: { type: String },
  companyAddress: { type: String },
  taxId: { type: String },
  manufacturingCapabilities: [String],
  certifications: [String],
  rating: { type: Number, default: 0 },
  totalProjects: { type: Number, default: 0 },
  activeProjects: { type: Number, default: 0 },
  leadTime: { type: Number }, // Average lead time in days
  minimumOrderValue: { type: Number },
});

const Supplier = mongoose.model("Supplier", SupplierSchema);
module.exports = Supplier;


=======================================================================
E:\My-Projects\Fastners-new\server\models\userModel.js

const mongoose = require("mongoose");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const config = require("../config/config");

const UserSchema = new mongoose.Schema(
  {
    email: {
      type: String,
      required: [true, "Please provide an email"],
      unique: true,
      match: [
        /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/,
        "Please provide a valid email",
      ],
    },
    password: {
      type: String,
      required: [true, "Please add a password"],
      minlength: 6,
      select: false,
    },
    role: {
      type: String,
      enum: ["customer", "admin", "supplier"],
    },
    firstName: {
      type: String,
      required: [true, "Please add a first name"],
    },
    lastName: {
      type: String,
      required: [true, "Please add a last name"],
    },
    phoneNumber: String,
    company: String,
    isVerified: {
      type: Boolean,
      default: false,
    },
    otp: {
      code: String,
      expiresAt: Date,
    },
  },
  { timestamps: true }
);

UserSchema.pre("save", async function (next) {
  if (!this.isModified("password")) {
    next();
  }
  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
});

UserSchema.methods.matchPassword = async function (enteredPassword) {
  return await bcrypt.compare(enteredPassword, this.password);
};

UserSchema.methods.getSignedJwtToken = function () {
  return jwt.sign({ id: this._id, role: this.role }, config.JWT_SECRET, {
    expiresIn: config.JWT_EXPIRE,
  });
};

module.exports = mongoose.model("User", UserSchema);


=======================================================================
E:\My-Projects\Fastners-new\server\routes\adminRoutes.js

// adminRoutes.js
const express = require("express");
const router = express.Router();
const {
  getAllUsers,
  getUserById,
  updateUser,
  deleteUser,
  getDashboardStats,
  forwardProjectToSuppliers,
  reviewQuotation,
  getAllSuppliers,
  getAllProjectUpdates,
  getProjectUpdateById,
  createProjectUpdate,
  updateProjectUpdate,
  deleteProjectUpdate,
} = require("../controllers/adminControllers");
const { protect, authorize } = require("../middleware/authMiddleware");

router.use(protect);
router.use(authorize("admin"));

router.get("/users", getAllUsers);
router.get("/suppliers", getAllSuppliers);
router.get("/users/:id", getUserById);
router.put("/users/:id", updateUser);
router.delete("/users/:id", deleteUser);
router.get("/dashboard", getDashboardStats);
router.post("/projects/:id/forward", forwardProjectToSuppliers);
router.post("/quotations/review", reviewQuotation);




// Project Update Routes
router.get("/project-updates", getAllProjectUpdates);
router.get("/project-updates/:id", getProjectUpdateById);
router.post("/project-updates", createProjectUpdate);
router.put("/project-updates/:id", updateProjectUpdate);
router.delete("/project-updates/:id", deleteProjectUpdate);

module.exports = router;


=======================================================================
E:\My-Projects\Fastners-new\server\routes\projectRoutes.js

// projectRoutes.js
const express = require("express");
const router = express.Router();
const {
  createProject,
  getProjects,
  getProjectById,
  updateProject,
  deleteProject,
  forwardToSuppliers,
  getProjectByUserId,
} = require("../controllers/projectControllers");
const { protect, authorize } = require("../middleware/authMiddleware");

router.use(protect);

router.post("/", authorize("customer"), createProject);
router.get("/", getProjects);
router.get(
  "/get-project-by-user-id",
  authorize("customer"),
  getProjectByUserId
);

router.get("/:id", getProjectById);

router.put("/:id", authorize("admin", "supplier"), updateProject);
router.delete("/:id", authorize("admin"), deleteProject);
router.post("/:id/forward", authorize("admin"), forwardToSuppliers);

module.exports = router;


=======================================================================
E:\My-Projects\Fastners-new\server\routes\quotationRoutes.js

// quotationRoutes.js
const express = require("express");
const router = express.Router();
const {
  createQuotation,
  getQuotations,
  getQuotationById,
  updateQuotation,
  acceptQuotation,
  updateQuotationStatus,
} = require("../controllers/quotationControllers");
const { protect, authorize } = require("../middleware/authMiddleware");

router.post("/projects/:projectId", protect, authorize("admin","supplier"), createQuotation);
router.get("/", protect, getQuotations);
router.get("/:id", protect, getQuotationById);
router.put("/:id", protect, authorize("admin"), updateQuotationStatus);
router.post("/:id/accept", protect, authorize("admin"), acceptQuotation);

module.exports = router;


=======================================================================
E:\My-Projects\Fastners-new\server\routes\supplierRoutes.js

const express = require("express");
const router = express.Router();
const {
  getSuppliers,
  getSupplierById,
  updateSupplier,
  getSupplierProjects,
  updateProjectStatus,
  getSupplierByUserId,
  updateCapabilities,
  getManufacturingCapabilities,
  getSupplierOrders,
} = require("../controllers/supplierControllers");
const { protect, authorize } = require("../middleware/authMiddleware");


router.get("/capabilities", protect, getManufacturingCapabilities);
router.get("/", protect, authorize("admin"), getSuppliers);
router.get("/me", protect, getSupplierByUserId);
router.get("/orders", protect, authorize("supplier"), getSupplierOrders);
// router.get("/bids", protect, authorize("supplier"), getSupplierBids);
// router.get("/active-projects", protect, authorize("supplier"), getSupplierActiveProjects);
router.get("/:id", protect, getSupplierById);
router.put("/:id", protect, authorize("admin", "supplier"), updateSupplier);
router.get(
  "/:id/projects",
  protect,
  authorize("admin", "supplier"),
  getSupplierProjects
);
router.post(
  "/update-project",
  protect,
  authorize("admin", "supplier"),
  updateProjectStatus
);

// Update capabilities (add/remove multiple at once)
router.post("/capabilities", protect, updateCapabilities);

module.exports = router;


=======================================================================
E:\My-Projects\Fastners-new\server\routes\userRoutes.js

// userRoutes.js
const express = require("express");
const router = express.Router();
const {
  register,
  login,
  verifyOTP,
  resendOTP,
  getProfile,
  updateProfile,
  forgotPassword,
  resetPassword,
  updatePassword,
} = require("../controllers/userControllers");
const { protect } = require("../middleware/authMiddleware");

router.post("/register", register);
router.post("/login", login);
router.post("/verify-otp", verifyOTP);
router.post("/resend-otp", resendOTP);
router.post("/forgot-password", forgotPassword);
router.post("/reset-password", resetPassword);

router.get("/profile", protect, getProfile);
router.put("/profile", protect, updateProfile);
router.put("/update-password", protect, updatePassword);

module.exports = router;


=======================================================================
E:\My-Projects\Fastners-new\server\utils\apiFeatures.js

// utils/apiFeatures.js

class APIFeatures {
  constructor(query, queryString) {
    this.query = query;
    this.queryString = queryString;
  }

  filter() {
    const queryObj = { ...this.queryString };
    const excludedFields = ["page", "sort", "limit", "fields", "search"];
    excludedFields.forEach((el) => delete queryObj[el]);

    let queryStr = JSON.stringify(queryObj);
    queryStr = queryStr.replace(/\b(gte|gt|lte|lt)\b/g, (match) => `$${match}`);

    this.query = this.query.find(JSON.parse(queryStr));
    return this;
  }

  sort() {
    if (this.queryString.sort) {
      const sortBy = this.queryString.sort.split(",").join(" ");
      this.query = this.query.sort(sortBy);
    } else {
      this.query = this.query.sort("-createdAt");
    }
    return this;
  }

  limitFields() {
    if (this.queryString.fields) {
      const fields = this.queryString.fields.split(",").join(" ");
      this.query = this.query.select(fields);
    } else {
      this.query = this.query.select("-__v");
    }
    return this;
  }

  paginate() {
    const page = parseInt(this.queryString.page, 10) || 1;
    const limit = parseInt(this.queryString.limit, 10) || 100;
    const skip = (page - 1) * limit;

    this.query = this.query.skip(skip).limit(limit);
    return this;
  }

  search() {
    if (this.queryString.search) {
      const searchFields = [
        "title",
        "description",
        "requirements.material",
        "requirements.process",
      ]; // Add or modify fields as needed
      const searchRegex = new RegExp(this.queryString.search, "i");
      const searchQuery = searchFields.map((field) => ({
        [field]: searchRegex,
      }));
      this.query = this.query.or(searchQuery);
    }
    return this;
  }
}

module.exports = APIFeatures;


=======================================================================
E:\My-Projects\Fastners-new\server\app.js

const express = require("express");
const connectDB = require("./config/dbConnection");
const userRoutes = require("./routes/userRoutes");
const projectRoutes = require("./routes/projectRoutes");
const quotationRoutes = require("./routes/quotationRoutes");
const supplierRoutes = require("./routes/supplierRoutes");
const adminRoutes = require("./routes/adminRoutes");
const cors = require("cors");

const app = express();

// Connect to database
connectDB();

// Use CORS middleware
app.use(cors());
// Middleware
app.use(express.json());

// Routes
app.use("/api/users", userRoutes);
app.use("/api/projects", projectRoutes);
app.use("/api/quotations", quotationRoutes);
app.use("/api/suppliers", supplierRoutes);
app.use("/api/admin", adminRoutes);
// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ success: false, message: "Something went wrong" });
});

const PORT = process.env.PORT || 5000;

app.listen(PORT, () => console.log(`Server running on port ${PORT}`));


